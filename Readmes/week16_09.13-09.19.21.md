# Algorithm practice

* Java documentations and extra notes are in each file.
* Solutions displayed here are preferably the most optimal
    * Alternative (less optimal) solutions might also be available within each 
    file

# Week 16: 09/13 - 09/19/2021

# Category for this week:
**[Linked List](#linked-list)**<br>

---

# Linked List

## [Linked List Palindrome](../LinkedList/src/main/java/LinkedListPalindrome.java)

#### Level: Very Hard ðŸ““

> question prompt

```java
public boolean linkedListPalindrome(LinkedList head) {
  Stack<Integer> stack = new Stack<>();
  LinkedList currNode = head;
  while (currNode != null) {
    if (stack.isEmpty()) {
      stack.add(currNode.value);
    } else {
      if (stack.peek() == currNode.value) {
        stack.pop();
      } else {
        stack.add(currNode.value);
      }
    }
    currNode = currNode.next;
  }
  return stack.isEmpty() || stack.size() == 1 ;
}
```

### Complexity???

---

# from week5 - need to take a look again

## [Leetcode #84 - Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)

#### Level: Hard ðŸ“•

```python
def largestRectangleArea(self, height):
  '''
  Function -- largestRectangleArea
    Fix here
  Parameter:
    n - some
  Return:
    placeholder
  '''
  n = len(height)

  # left[i], right[i] represent how many bars are >= than the current bar

  left = [1] * n
  right = [1] * n
  max_rect = 0

  # calculate left
  for i in range(0, n):
    j = i - 1
    while j >= 0:
      if height[j] >= height[i]:
        left[i] += left[j]
        j -= left[j]
      else: break

  # calculate right
  for i in range(n - 1, -1, -1):
    j = i + 1
    while j < n:
      if height[j] >= height[i]:
        right[i] += right[j]
        j += right[j]
      else: break

  for i in range(0, n):
    max_rect = max(max_rect, height[i] * (left[i] + right[i] - 1))

  return max_rect
```

### Complexity???

## [Leetcode #340 - Longest Substring with At Most K Distinct Characters]()

```python
def lengthOfLongestSubstringKDistinct(s: str, k: int) -> int:
  '''
  Function -- climbStairs
    Placeholder
  Parameter:
    n - some
  Return:
    Placeholder
  '''
  d = {}
  j, longest = 0, 0
  for i in range(len(s)):
    # default 0 otherwise d.get(s[i]) then add 1
    d[s[i]] = d.get(s[i], 0) + 1
    while len(d) > k:  # keep incrementing j until duplicate count goes down
      d[s[j]] -= 1
      if d[s[j]] == 0:  # duplicate removed
        d.pop(s[j])
      j += 1
    longest = max(longest, i - j + 1)
  return longest
```

### Complexity???

---

# Stacks

## [Sunset Views](../Stacks/src/main/java/SunsetViews.java)

#### Level: Medium ðŸ“˜

```java
unsolved - need to finish
```