# Algorithm practice

* Java documentations and extra notes are in each file.
* Solutions displayed here are preferably the most optimal
    * Alternative (less optimal) solutions might also be available within each 
    file

# Week 16: 09/13 - 09/19/2021

# Category for this week:
**[Linked List](#linked-list)**<br>
**[Searching](#searching)**<br>


---

# Linked List

## [Linked List Palindrome](../LinkedList/src/main/java/LinkedListPalindrome.java)
* See function *reverseLinkedList* in this file or at its own [problem](../LinkedList/src/main/java/ReverseLinkedList.java)

#### Level: Very Hard ðŸ““

> Write a function that takes in the head of a Singly Linked List and returns a boolean representing whether the linked list's nodes form a palindrome. Your function shouldn't make use of any auxiliary data structure.
>
> A palindrome is usually defined as a string that's written the same forward and backward. For a linked list's nodes to form a palindrome, their values must be the same when read from left to right and from right to left. Note that single-character strings are palindromes, which means that single-node linked lists form palindromes.

```java
public boolean linkedListPalindrome(LinkedList head) {
  LinkedList slowNode = head;
  LinkedList fastNode = head;
  while (fastNode != null && fastNode.next != null) {
    slowNode = slowNode.next;
    fastNode = fastNode.next.next;
  }
  LinkedList reversedSecondHalfNode = reverseLinkedList(slowNode);
  LinkedList firstHalfNode = head;
  while (reversedSecondHalfNode != null) {
    if (reversedSecondHalfNode.value != firstHalfNode.value) return false;
    reversedSecondHalfNode = reversedSecondHalfNode.next;
    firstHalfNode = firstHalfNode.next;
  }
  return true;
}
```

### O(n) time | O(1) space

---

# Searching

## [Binary Search](../Searching/src/main/java/BinarySearch.java)

#### Level: Easy ðŸ“—

> Write a function that takes in a sorted array of integers as well as a target integer. The function should use the Binary Search algorithm to determine if the target integer is contained in the array and should return its index if it is, otherwise `-1`.

```java
public static int binarySearch(int[] array, int target) {
  int start = 0, end = array.length - 1;
  while (start <= end) {
    int mid = (start + end) / 2;
    if (array[mid] == target) return mid;
    if (target < array[mid]) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }
  return -1;
}
```

### O(log(n)) time | O(1) space

## [Find Three Largest Numbers](../Searching/src/main/java/FindThreeLargestNum.java)

#### Level: Easy ðŸ“—

> Write a function that takes in an array of at least three integers and, without sorting the input array, returns a sorted array of the three largest integers in the input array.
>
> The function should return duplicate integers if necessary; for example, it should return `[10, 10, 12]` for an input array of `[10, 5, 9, 10, 12]`.

```java
public static int[] findThreeLargestNumbers(int[] array) {
  int[] sortedThreeLargestNum = {Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE};
  for (int num : array) {
    updateLargest(sortedThreeLargestNum, num);
  }
  return sortedThreeLargestNum;
}

public static void updateLargest(int[] threeLargest, int num) {
  if (num > threeLargest[2]) {
    shiftAndUpdate(threeLargest, num, 2);
  } else if (num > threeLargest[1]) {
    shiftAndUpdate(threeLargest, num, 1);
  } else if (num > threeLargest[0]) {
    shiftAndUpdate(threeLargest, num, 0);
  }
}

public static void shiftAndUpdate(int[] threeLargest, int num, int position) {
  for (int i = 0; i <= position; i++) {
    if (i == position) {
      threeLargest[i] = num;
    } else {
      threeLargest[i] = threeLargest[i + 1];
    }
  }
}
```

### O(n) time | O(1) space

## [Search In Sorted Matrix](../Searching/src/main/java/SearchInSortedMatrix.java)

#### Level: Medium ðŸ“˜

> You're given a two-dimensional array (a matrix) of distinct integers and a target integer. Each row in the matrix is sorted, and each column is also sorted; the matrix doesn't necessarily have the same height and width.
>
> Write a function that returns an array of the row and column indices of the target integer if it's contained in the matrix, otherwise `[-1, -1]`.

```java
public static int[] searchInSortedMatrix(int[][] matrix, int target) {
  int[] notFound = new int[] {-1, -1};
  for (int i = 0; i < matrix.length; i++) {
    int[] rowResult = binarySearch(matrix[i], i, target);
    if (!Arrays.equals(rowResult, notFound)) return rowResult;
  }
  return notFound;
}

public static int[] binarySearch(int[] rowArr, int rowPos, int target) {
  int start = 0, end = rowArr.length - 1;
  while (start <= end) {
    int mid = (start + end) / 2;
    if (rowArr[mid] == target) return new int[] {rowPos, mid};
    if (target < rowArr[mid]) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }
  return new int[] {-1, -1};
}
```

### O(mlog(n)) time | O(1) space - where n is length of matrix's rows and m is length of matrix's columns.

---

# from week5 - need to take a look again

## [Leetcode #84 - Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)

#### Level: Hard ðŸ“•

```python
def largestRectangleArea(self, height):
  '''
  Function -- largestRectangleArea
    Fix here
  Parameter:
    n - some
  Return:
    placeholder
  '''
  n = len(height)

  # left[i], right[i] represent how many bars are >= than the current bar

  left = [1] * n
  right = [1] * n
  max_rect = 0

  # calculate left
  for i in range(0, n):
    j = i - 1
    while j >= 0:
      if height[j] >= height[i]:
        left[i] += left[j]
        j -= left[j]
      else: break

  # calculate right
  for i in range(n - 1, -1, -1):
    j = i + 1
    while j < n:
      if height[j] >= height[i]:
        right[i] += right[j]
        j += right[j]
      else: break

  for i in range(0, n):
    max_rect = max(max_rect, height[i] * (left[i] + right[i] - 1))

  return max_rect
```

### Complexity???

## [Leetcode #340 - Longest Substring with At Most K Distinct Characters]()

```python
def lengthOfLongestSubstringKDistinct(s: str, k: int) -> int:
  '''
  Function -- climbStairs
    Placeholder
  Parameter:
    n - some
  Return:
    Placeholder
  '''
  d = {}
  j, longest = 0, 0
  for i in range(len(s)):
    # default 0 otherwise d.get(s[i]) then add 1
    d[s[i]] = d.get(s[i], 0) + 1
    while len(d) > k:  # keep incrementing j until duplicate count goes down
      d[s[j]] -= 1
      if d[s[j]] == 0:  # duplicate removed
        d.pop(s[j])
      j += 1
    longest = max(longest, i - j + 1)
  return longest
```

### Complexity???

---

# Stacks

## [Sunset Views](../Stacks/src/main/java/SunsetViews.java)

#### Level: Medium ðŸ“˜

```java
unsolved - need to finish
```