# Algorithm practice

* Java documentations and extra notes are in each file.
* Solutions displayed here are preferably the most optimal
    * Alternative (less optimal) solutions might also be available within each 
    file

# Week 16: 09/13 - 09/19/2021

# Category for this week:
**[Linked List](#linked-list)**<br>

---

# Linked List

## [Linked List Palindrome](../LinkedList/src/main/java/LinkedListPalindrome.java)

#### Level: Very Hard ðŸ““

> Write a function that takes in the head of a Singly Linked List and returns a boolean representing whether the linked list's nodes form a palindrome. Your function shouldn't make use of any auxiliary data structure.
>
> A palindrome is usually defined as a string that's written the same forward and backward. For a linked list's nodes to form a palindrome, their values must be the same when read from left to right and from right to left. Note that single-character strings are palindromes, which means that single-node linked lists form palindromes.

```java
public boolean linkedListPalindrome(LinkedList head) {
  LinkedList reversedLLHead = reverseLinkedList(head);
  LinkedList currNode = head;
  LinkedList currReverseNode = reversedLLHead;
  while (currNode != null) {
    if (currNode.value != currReverseNode.value) return false;
    currNode = currNode.next;
    currReverseNode = currReverseNode.next;
  }
  return true;
}

public static LinkedList reverseLinkedList(LinkedList head) {
  LinkedList currNode = head;
  LinkedList prevNode = null;
  while (currNode != null) {
    LinkedList nextNode = currNode.next;
    currNode.next = prevNode;
    prevNode = currNode;
    currNode = nextNode;
  }
  return prevNode;
}
```

### O(n) time | O(1) space

---

# from week5 - need to take a look again

## [Leetcode #84 - Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)

#### Level: Hard ðŸ“•

```python
def largestRectangleArea(self, height):
  '''
  Function -- largestRectangleArea
    Fix here
  Parameter:
    n - some
  Return:
    placeholder
  '''
  n = len(height)

  # left[i], right[i] represent how many bars are >= than the current bar

  left = [1] * n
  right = [1] * n
  max_rect = 0

  # calculate left
  for i in range(0, n):
    j = i - 1
    while j >= 0:
      if height[j] >= height[i]:
        left[i] += left[j]
        j -= left[j]
      else: break

  # calculate right
  for i in range(n - 1, -1, -1):
    j = i + 1
    while j < n:
      if height[j] >= height[i]:
        right[i] += right[j]
        j += right[j]
      else: break

  for i in range(0, n):
    max_rect = max(max_rect, height[i] * (left[i] + right[i] - 1))

  return max_rect
```

### Complexity???

## [Leetcode #340 - Longest Substring with At Most K Distinct Characters]()

```python
def lengthOfLongestSubstringKDistinct(s: str, k: int) -> int:
  '''
  Function -- climbStairs
    Placeholder
  Parameter:
    n - some
  Return:
    Placeholder
  '''
  d = {}
  j, longest = 0, 0
  for i in range(len(s)):
    # default 0 otherwise d.get(s[i]) then add 1
    d[s[i]] = d.get(s[i], 0) + 1
    while len(d) > k:  # keep incrementing j until duplicate count goes down
      d[s[j]] -= 1
      if d[s[j]] == 0:  # duplicate removed
        d.pop(s[j])
      j += 1
    longest = max(longest, i - j + 1)
  return longest
```

### Complexity???

---

# Stacks

## [Sunset Views](../Stacks/src/main/java/SunsetViews.java)

#### Level: Medium ðŸ“˜

```java
unsolved - need to finish
```