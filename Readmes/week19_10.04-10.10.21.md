# Algorithm practice

* Java documentations and extra notes are in each file.
* Solutions displayed here are preferably the most optimal
  * Alternative (less optimal) solutions might also be available within each 
  file

# Week 19: 10/04 - 10/10/2021

# Category for this week:
No specification

---

## [Leetcode #36 - Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)

#### Level: Medium ğŸ“˜

```python
def isValidSudoku(self, board):
  """
  :type board: List[List[str]]
  :rtype: bool
  
  Test case:
  1. Valid sudoku
  2. Invalid one
  3. Null
  
  Approach: 
  Array: 1,2,3,4,5
  String: 12345 -> parse thru the whole string -> not good
  HashMap - HashSet: b/c complexity to look up O(1)
  """
  storing_set = set()
  for row_idx in range(len(board)):
    for col_idx in range(len(board[0])):
      val = board[row_idx][col_idx]
      if val == ".":
        continue
      row_val = val + "row" + str(row_idx)
      col_val = val + "col" + str(col_idx)
      sub_matrix_val = val + "sub" + str(row_idx // 3) + str(col_idx // 3)
      if row_val in storing_set or col_val in storing_set or sub_matrix_val in \
        storing_set:
        return False
      storing_set.add(row_val)
      storing_set.add(col_val)
      storing_set.add(sub_matrix_val)
  return True
```

### O(n^2) time | O(n^2) space - because must loop thru every element in matrix

## [Leetcode #5 - Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

#### Level: Medium ğŸ“˜

```python
class Solution(object):
  def longestPalindrome(self, s):
    """
    :type s: str
    :rtype: str
    """
    longest = [0, 1]
    for i in range(1, len(s)):
      odd = self.getLongestPalindrome(i - 1, i + 1, s)
      even = self.getLongestPalindrome(i - 1, i, s)
      curr_longest = odd if odd[1] - odd[0] > even[1] - even[0] else even
      longest = longest if longest[1] - longest[0] > curr_longest[1] - curr_longest[0] else curr_longest
    return s[longest[0]:longest[1]]
  
  def getLongestPalindrome(self, start, end, s):
    while (start >= 0 and end < len(s)):
      if (s[start] != s[end]):
        break
      start -= 1
      end += 1
    return [start + 1, end]
```

### O(n^2) time | O(n) space

## [Leetcode #51 - N-Queens](https://leetcode.com/problems/n-queens/)
* DP / DFS

#### Level: Hard ğŸ“•

```python
class Solution(object):
  def __init__(self):
    self.blockedCols = set()
    self.blockedUpDiags = set()
    self.blockedDownDiags = set()
    
    self.board = []
    self.result = []
  
  def solveNQueens(self, n):
    """
    :type n: int
    :rtype: List[List[str]]
    """
    self.board = [["."] * n for row in range(n)]
    self.iterate(n, 0)
    return self.result
  
  def iterate(self, n, r):
    # base case: return result
    if r == n: # meaning it gets to the last row
      self.result.append(self.refineOutput())
      return
    # other, need to place queen
    for c in range(n):
      # check for invalid options, if invalid pass,
      # else place queen, block positions
      if not self.checkInvalidPos(r, c):
        self.placeAndUpdate(r, c)
        self.iterate(n, r + 1)
        # clean up
        self.cleanUp(r, c)
          
  def checkInvalidPos(self, r, c):
    return c in self.blockedCols or (c + r) in self.blockedUpDiags or (r - c) in self.blockedDownDiags
  
  def placeAndUpdate(self, r, c):
    self.board[r][c] = "Q"
    self.blockedCols.add(c)
    self.blockedUpDiags.add(r + c)
    self.blockedDownDiags.add(r - c)
      
  def cleanUp(self, r, c):
    self.board[r][c] = "."
    self.blockedCols.remove(c)
    self.blockedUpDiags.remove(r + c)
    self.blockedDownDiags.remove(r - c)
      
  def refineOutput(self):
    return ["".join(row) for row in self.board]
```

### O(n^2) time | O(n^2) space

## [Leetcode #884 - Uncommon Words from Two Sentences](https://leetcode.com/problems/uncommon-words-from-two-sentences/)

#### Level: Easy ğŸ“—

```python
def uncommonFromSentences(self, s1, s2):
  """
  :type s1: str
  :type s2: str
  :rtype: List[str]
  """
  combine_list = s1.split() + s2.split()
  result = []
  for word in combine_list:
    if combine_list.count(word) == 1:
      result.append(word)
  return result
```

### O(n + m) time | O(n + m) space - where n and m is length of s1 and s2 respectively
