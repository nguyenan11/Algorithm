# Algorithm practice

* Java documentations and extra notes are in each file.
* Solutions displayed here are preferably the most optimal
  * Alternative (less optimal) solutions might also be available within each 
  file

# Week 19: 10/04 - 10/10/2021

# Category for this week:

---

## [Leetcode #36 - Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)

#### Level: Medium ğŸ“˜

```python
def isValidSudoku(self, board):
  """
  :type board: List[List[str]]
  :rtype: bool
  
  Test case:
  1. Valid sudoku
  2. Invalid one
  3. Null
  
  Approach: 
  Array: 1,2,3,4,5
  String: 12345 -> parse thru the whole string -> not good
  HashMap - HashSet: b/c complexity to look up O(1)
  """
  storing_set = set()
  for row_idx in range(len(board)):
    for col_idx in range(len(board[0])):
      val = board[row_idx][col_idx]
      if val == ".":
        continue
      row_val = val + "row" + str(row_idx)
      col_val = val + "col" + str(col_idx)
      sub_matrix_val = val + "sub" + str(row_idx // 3) + str(col_idx // 3)
      if row_val in storing_set or col_val in storing_set or sub_matrix_val in \
        storing_set:
        return False
      storing_set.add(row_val)
      storing_set.add(col_val)
      storing_set.add(sub_matrix_val)
  return True
```

### O(n^2) time | O(n^2) space - because must loop thru every element in matrix

## [Leetcode #5 - Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

#### Level: Medium ğŸ“˜

```python
class Solution(object):
  def longestPalindrome(self, s):
    """
    :type s: str
    :rtype: str
    """
    longest = [0, 1]
    for i in range(1, len(s)):
      odd = self.getLongestPalindrome(i - 1, i + 1, s)
      even = self.getLongestPalindrome(i - 1, i, s)
      curr_longest = odd if odd[1] - odd[0] > even[1] - even[0] else even
      longest = longest if longest[1] - longest[0] > curr_longest[1] - curr_longest[0] else curr_longest
    return s[longest[0]:longest[1]]
  
  def getLongestPalindrome(self, start, end, s):
    while (start >= 0 and end < len(s)):
      if (s[start] != s[end]):
        break
      start -= 1
      end += 1
    return [start + 1, end]
```

### O(n^2) time | O(n) space
