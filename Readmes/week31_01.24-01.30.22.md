# Algorithm practice

# Week 31: 01/24 - 01/30/2022

# Category for this week:
**[Dynamic Programming](#dynamic-programming)**<br>

Small tip: Any problem with maximum, minimum, or number of ways... usually a DP problem

---

# Dynamic Programming

## [Leetcode #983 - Minimum Cost For Tickets](https://leetcode.com/problems/minimum-cost-for-tickets/)

#### Level: Medium ðŸ“˜

```python
def mincostTickets(self, days: List[int], costs: List[int]) -> int:
  dp = {} # using cache
  
  def dfs(index):
    if index == len(days): # base case, no more day left to travel
      return 0
    if index in dp:
      return dp[index]
    
    dp[index] = float("inf")
    for day, cost in zip([1, 7, 30], costs): # O(30)
      j = index
      while j < len(days) and days[j] < days[index] + day:
        j += 1
      dp[index] = min(dp[index], cost + dfs(j))
    return dp[index]
  
  return dfs(0) # index 0 of days
```

### O(n) time | O(n) space
