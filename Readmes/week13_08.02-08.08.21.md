# Algorithm practice

* Java documentations and extra notes are in each file.
* Solutions displayed here are preferably the most optimal
    * Alternative (less optimal) solutions might also be available within each 
    file

# Week 13: 08/02 - 08/08/2021

# Category for this week:
**[Graph](#graph)**<br>

---

# Graph

## [Depth-first Search](../Graph/src/main/java/DepthFirstSearch.java)

#### Level: Easy ðŸ“—

> You're given a `Node` class that has a `name` and an array of optional `children` nodes. When put together, nodes form an acyclic tree-like structure.
>
> Implement the `depthFirstSearch` method on the `Node` class, which takes in an empty array, traverses the tree using the Depth-first Search approach (specifically navigating the tree from left to right), stores all of the nodes' names in the input array, and returns it.

![DFS Sample](../Graph/src/main/java/DFS_sample.png)

```java
static class Node {

  String name;
  List<Node> children = new ArrayList<Node>();

  public Node(String name) {
    this.name = name;
  }

  public Node addChild(String name) {
    Node child = new Node(name);
    children.add(child);
    return this;
  }

  public List<String> depthFirstSearch(List<String> array) {
    array.add(this.name);
    for (Node child : children) {
      child.depthFirstSearch(array);
    }
    return array;
  }

}
```

### O(v + e) time | O(v) space - v is number of vertices, e is number of edges

## [Breadth-first Search](../Graph/src/main/java/BreadthFirstSearch.java)

#### Level: Medium ðŸ“˜

> You're given a `Node` class that has a `name` and an array of optional `children` nodes. When put together, nodes form an acyclic tree-like structure.
>
> Implement the `breadthFirstSearch` method on the `Node` class, which takes in an empty array, traverses the tree using the Breadth-first Search approach (specifically navigating the tree from left to right), stores all of the nodes' names in the input array, and returns it.

![BFS Sample](../Graph/src/main/java/BFS_sample.png)

```java
static class Node {

  String name;
  List<Node> children = new ArrayList<Node>();

  public Node(String name) {
    this.name = name;
  }

  public Node addChild(String name) {
    Node child = new Node(name);
    children.add(child);
    return this;
  }

  public List<String> depthFirstSearch(List<String> array) {
    array.add(this.name);
    for (Node child : children) {
      child.depthFirstSearch(array);
    }
    return array;
  }

}
```

### O(v + e) time | O(v) space - v is number of vertices, e is number of edges