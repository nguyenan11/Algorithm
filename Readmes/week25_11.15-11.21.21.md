# Algorithm practice

# Week 25: 11/15 - 11/21/2021

# Category for this week:
**[Interval](#interval)**<br>
**[Linked List](#linked-list)**<br>
**[Strings](#strings)**<br>
**[Tree](#tree)**<br>

---

# Interval

## [Leetcode #57 - Insert Interval](https://leetcode.com/problems/insert-interval/)

#### Level: Medium ðŸ“˜

```python
def insert(self, intervals, newInterval):
  """
  :type intervals: List[List[int]]
  :type newInterval: List[int]
  :rtype: List[List[int]]
  """
  if not intervals:
    return [newInterval]
  
  result = []
  for i in range(len(intervals)):
    if newInterval[1] < intervals[i][0]:
      result.append(newInterval)
      return result + intervals[i:]
    elif newInterval[0] > intervals[i][1]:
      result.append(intervals[i])
    else:
      newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]
  result.append(newInterval)
  return result
```

### O(n) time | O(n) space

## [Leetcode #56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)

#### Level: Medium ðŸ“˜

```python
def merge(self, intervals):
  """
  :type intervals: List[List[int]]
  :rtype: List[List[int]]
  """
  intervals.sort(key=lambda interval : interval[0])
  result = [intervals[0]]
  for start, end in intervals[1:]:
    prevEnd = result[-1][1]
    if start <= prevEnd: # meaning overlapping
      result[-1][1] = max(prevEnd, end)
    else:
      result.append([start, end])
  return result
```

### O(n * log n) time | O(n) space

## [Leetcode #435 - Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)

#### Level: Medium ðŸ“˜

```python
def eraseOverlapIntervals(self, intervals):
  """
  :type intervals: List[List[int]]
  :rtype: int
  """
  intervals.sort()
  count = 0
  prevEnd = intervals[0][1]
  for start, end in intervals[1:]:
    if start >= prevEnd: # no overlapping
      prevEnd = end
    else: # overlapping
      count += 1
      prevEnd = min(prevEnd, end)
  return count
```

### O(n * log n) time | O(1) space

---

# Linked List

## [Leetcode #206 - Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)

#### Level: Easy ðŸ“—

```python
def reverseList(self, head):
  """
  :type head: ListNode
  :rtype: ListNode
  """
  prevNode = None
  currNode = head
  while currNode != None:
    nextNode = currNode.next
    currNode.next = prevNode
    prevNode = currNode
    currNode = nextNode
  return prevNode
```

### O(n) time | O(1) space

## [Leetcode #141 - Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

#### Level: Easy ðŸ“—

```python
def hasCycle(self, head):
  """
  :type head: ListNode
  :rtype: bool
  """
  slowPtr, fastPtr = head, head
  while fastPtr and fastPtr.next:
    slowPtr = slowPtr.next
    fastPtr = fastPtr.next.next
    if slowPtr == fastPtr:
      return True
  return False
```

### O(n) time | O(1) space

## [Leetcode #23 - Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)

#### Level: Hard ðŸ“•

```python
# Divide and Conquer
def mergeKLists(self, lists):
  """
  :type lists: List[ListNode]
  :rtype: ListNode
  """
  if not lists or len(lists) == 0:
    return None
  
  while len(lists) > 1:
    mergedLists = []
    for i in range(0, len(lists), 2):
      l1 = lists[i]
      l2 = lists[i + 1] if (i + 1) < len(lists) else None # oddNum of lists
      mergedLists.append(self.merge2Lists(l1, l2))
    lists = mergedLists
  return lists[0]
                
        
def merge2Lists(self, l1, l2):
  dummy = currNode = ListNode(0)
  while l1 and l2:
    if l1.val < l2.val:
      currNode.next = l1
      l1 = l1.next
    else:
      currNode.next = l2
      l2 = l2.next
    currNode = currNode.next
  currNode.next = l1 or l2
  return dummy.next
```

### O(n * log k) time | O(n) space

## [Leetcode #19 - Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

#### Level: Medium ðŸ“˜

```python
def removeNthFromEnd(self, head, n):
  """
  :type head: ListNode
  :type n: int
  :rtype: ListNode
  """
  # set dummy to head will have left sit on the deleted Node, not the one before it
  dummy = ListNode(0, head) 
  leftPtr = dummy
  rightPtr = head
  
  while n > 0 and rightPtr:
    rightPtr = rightPtr.next
    n -= 1
  
  while rightPtr:
    leftPtr = leftPtr.next
    rightPtr = rightPtr.next
      
  # deletion
  leftPtr.next = leftPtr.next.next
  return dummy.next
```

### O(n) time | O(1) space

## [Leetcode #143 - Reorder List](https://leetcode.com/problems/reorder-list/)

#### Level: Medium ðŸ“˜

```python
def reorderList(self, head):
  """
  :type head: ListNode
  :rtype: None Do not return anything, modify head in-place instead.
  """
  # find middle
  slowPtr, fastPtr = head, head.next
  while fastPtr and fastPtr.next:
    slowPtr = slowPtr.next
    fastPtr = fastPtr.next.next
      
  # reverse the second half
  second = slowPtr.next
  prev = slowPtr.next = None
  while second:
    nextNode = second.next
    second.next = prev
    prev = second
    second = nextNode
      
  # merge two halfs
  first, second = head, prev
  while second:
    tmp1, tmp2 = first.next, second.next
    first.next = second
    second.next = tmp1
    first, second = tmp1, tmp2
```

### O(n) time | O(1) space

---

# Strings

## [Leetcode #424 - Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)
* Sliding Window

#### Level: Medium ðŸ“˜

```python
def characterReplacement(self, s, k):
  """
  :type s: str
  :type k: int
  :rtype: int
  """
  count = {}
  result = 0
  left = 0
  for right, char in enumerate(s):
    count[char] = count.get(char, 0) + 1
    # right - left + 1 is current window length
    # max(count.values()) max occurrences of a char in window
    while (right - left + 1) - max(count.values()) > k:
      count[s[left]] -= 1
      left += 1
    result = max(result, right - left + 1)
  return result
```

### O(n) time - from O(26n) | O(1) space - from O(26)

## [Leetcode #76 - Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

#### Level: Hard ðŸ“•

```python
def minWindow(self, s, t):
  """
  :type s: str
  :type t: str
  :rtype: str
  """
  if t == "":
    return ""
  
  countCharT, window = {}, {}
  
  for char in t:
    countCharT[char] = countCharT.get(char, 0) + 1
      
  have, need = 0, len(countCharT)
  result, resLen = [-1, -1], float("inf")
  left = 0
  
  for right, char in enumerate(s):
    window[char] = window.get(char, 0) + 1
    if char in countCharT and window[char] == countCharT[char]:
      have += 1
      while have == need:
        # update result
        if (right - left + 1) < resLen:
          result = [left, right]
          resLen = right - left + 1
        # pop from left of our window
        window[s[left]] -= 1
        if s[left] in countCharT and window[s[left]] < countCharT[s[left]]:
          have -= 1
        left += 1
  left, right = result
  return s[left:right + 1] if resLen != float("inf") else ""
```

### O(n) time | O(m) space - n is number of characters, m is number of unique characters in String s

## [Leetcode #125 - Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)

#### Level: Easy ðŸ“—

```python
from string import punctuation

class Solution(object):
  def isPalindrome(self, s):
    """
    :type s: str
    :rtype: bool
    """
    s = "".join("" if char in punctuation or char == " " else char for char in s)
    s = s.lower()
    return self.palindromeCheck(s)
      
  def palindromeCheck(self, string):
    leftIdx = 0
    rightIdx = len(string) - 1
    while leftIdx < rightIdx:
      if string[leftIdx] != string[rightIdx]:
        return False
      leftIdx += 1
      rightIdx -= 1
    return True
```

### O(n) time | O(1) space

## [Leetcode #647 - Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)

#### Level: Medium ðŸ“˜

```python
def countSubstrings(self, s):
  """
  :type s: str
  :rtype: int
  """
  result = 0
  
  for i in range(len(s)):
      
    # odd
    l = r = i
    while l >= 0 and r < len(s) and s[l] == s[r]:
      result += 1
      l -= 1
      r += 1
    
    # even
    l, r = i, i + 1
    while l >= 0 and r < len(s) and s[l] == s[r]:
      result += 1
      l -= 1
      r += 1
      
  return result
```

### O(n^2) time | O(1) space

---

# Tree

## [Leetcode #104 - Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

#### Level: Easy ðŸ“—

> DFS recursive
```python
def maxDepth(self, root):
  """
  :type root: TreeNode
  :rtype: int
  """
  if not root:
    return 0
  return self.dfs(root)

def dfs(self, node):
  count, countLeft, countRight = 1, 0, 0
  if node.left:
    countLeft = self.dfs(node.left)
  if node.right:
    countRight = self.dfs(node.right)
  count += max(countLeft, countRight)
  return count
```

### O(n) time | O(n) space

> BFS iterative
```python
def maxDepth(self, root):
  """
  :type root: TreeNode
  :rtype: int
  """
  if not root:
    return 0
  
  level = 0
  q = deque([root])
  while q:
    for i in range(len(q)):
      node = q.popleft()
      if node.left:
        q.append(node.left)
      if node.right:
        q.append(node.right)
    level += 1
  return level
```

### O(n) time | O(n) space

> DFS iterative
```python
def maxDepth(self, root):
  """
  :type root: TreeNode
  :rtype: int
  """
  stack = [[root, 1]]
  result = 0
  while stack:
    node, depth = stack.pop()
    if node:
      result = max(result, depth)
      stack.append([node.left, depth + 1])
      stack.append([node.right, depth + 1])
  return result
```

### O(n) time | O(n) space

## [Leetcode #100 - Same Tree](https://leetcode.com/problems/same-tree/)

#### Level: Easy ðŸ“—

```python
def isSameTree(self, p, q):
  """
  :type p: TreeNode
  :type q: TreeNode
  :rtype: bool
  """
  if p is None and q is None:
    return True
  if (p and not q) or (q and not p) or p.val != q.val:
    return False
  return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

### O(n) time | O(1) space??
