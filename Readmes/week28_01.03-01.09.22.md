# Algorithm practice

* Java documentations and extra notes are in each file.

# Week 28: 01/03 - 01/09/2021

# Category for this week:
**[Recursion](#recursion)**<br>

---

# Recursion

## [Permutations](../Recursion/src/main/java/Permutations.java)

#### Level: Medium ðŸ“˜

> Write a function that takes in an array of unique integers and returns an array of all permutations of those integers in no particular order.
> If the input array is empty, the function should return an empty array.

```java
public static List<List<Integer>> getPermutations(List<Integer> array) {
  List<List<Integer>> permutations = new ArrayList<List<Integer>>();
  getPermutations(0, array, permutations);
  return permutations;
}

public static void getPermutations(int i, List<Integer> array, List<List<Integer>> permutations) {
  if (i == array.size() - 1) {
    permutations.add(new ArrayList<Integer>(array));
  } else {
    for (int j = i; j < array.size(); j++) {
      swap(array, i, j);
      getPermutations(i + 1, array, permutations);
      swap(array, i, j);
    }
  }
}

public static void swap(List<Integer> array, int i, int j) {
  Integer temp = array.get(i);
  array.set(i, array.get(j));
  array.set(j, temp);
}
```

### O(n * n!) time | O(n * n!) space

## [Powerset](../Recursion/src/main/java/Powerset.java)

#### Level: Medium ðŸ“˜

> Write a function that takes in an array of unique integers and returns its powerset.
>
> The powerset `P(X)` of a set `X` is the set of all subsets of `X`. For example, the powerset of `[1,2]` is `[[], [1], [2], [1,2]]`.
>
> Note that the sets in the powerset do not need to be in any particular order.

```java
public static List<List<Integer>> powerset(List<Integer> array) {
  return powerset(array, array.size() - 1);
}

// recursion step
public static List<List<Integer>> powerset(List<Integer> array, int idx) {
  if (idx < 0) {
    List<List<Integer>> emptySet = new ArrayList<List<Integer>>();
    emptySet.add(new ArrayList<Integer>());
    return emptySet;
  }
  int num = array.get(idx);
  List<List<Integer>> subsets = powerset(array, idx - 1);
  int length = subsets.size();
  for (int i = 0; i < length; i++) {
    List<Integer> currSubset = new ArrayList<Integer>(subsets.get(i));
    currSubset.add(num);
    subsets.add(currSubset);
  }
  return subsets;
}
```

### O(n * 2^n) time | O(n * 2^n) space

## [Staircase Traversal](../Recursion/src/main/java/StaircaseTraversal.java)

#### Level: Medium ðŸ“˜

> You're given two positive integers representing the height of a staircase and the maximum number of steps that you can advance up the staircase at a time. Write a function that returns the number of ways in which you can climb the staircase.
>
> For example, if you were given a staircase of `height = 3` and `maxSteps = 2` you could climb the staircase in 3 ways. You could take **1 step, 1 step, then 1 step**, you could also take **1 step, then 2 steps**, and you could take **2 steps, then 1 step**.
>
> Note that `maxSteps <= height` will always be true.

```java
public int staircaseTraversal(int height, int maxSteps) {
  int[] waysToTop = new int[height + 1];
  waysToTop[0] = 1;
  waysToTop[1] = 1;
  for (int currHeight = 2; currHeight < height + 1; currHeight++) {
    int step = 1;
    while (step <= maxSteps && step <= currHeight) {
      waysToTop[currHeight] += waysToTop[currHeight - step];
      step += 1;
    }
  }
  return waysToTop[height];
}
```

### O(n * k) time | O(n) space - n is height of staircases and k is number of allowed steps
