# Algorithm practice

* Java documentations and extra notes are in each file.
* Solutions displayed here are preferably the most optimal
    * Alternative (less optimal) solutions might also be available within each 
    file

# Week 18: 09/27 - 10/03/2021

# Category for this week:

---

## [Leetcode #146 - LRU Cache](https://leetcode.com/problems/lru-cache/)

#### Level: Medium ðŸ“˜

```python
class LRUCache:

  # can capacity be negative? If so, need validation? return 0?

  def __init__(self, capacity):
    """
    :type capacity: int
    """
    self.capacity = capacity
    self.cache = OrderedDict()
      

  def get(self, key):
    """
    :type key: int
    :rtype: int
    """
    if key in self.cache:
        self.cache.move_to_end(key)
        return self.cache[key]
    return -1
      

  def put(self, key, value):
    """
    :type key: int
    :type value: int
    :rtype: None
    """
    if key in self.cache:
      self.cache.update({key: value})
      self.cache.move_to_end(key)
      return
    
    if self.capacity == len(self.cache):
      self.cache.popitem(last=False)
    
    # this works for the above if statement and also when capacity isn't met
    self.cache.update({key: value})
```
> This implementation works for Python3 and above, Python2 doesn't support function `move_to_end()` and `popitem()` of dict.

### O(1) time | O(1) space - as expected from the question

## [Leetcode #1010 - Pairs of Songs With Total Durations Divisible by 60](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/)

#### Level: Medium ðŸ“˜

```python
def numPairsDivisibleBy60(self, time):
  """
  :type time: List[int]
  :rtype: int
  
  similar to TwoSum problem
  """
  count = 0
  t_array = [0] * 60
  for t in time:
    # This to avoid when t % 60 = 0 -> 60 - t will be 60 -> algo won't work
    count += t_array[(60 - t % 60) % 60] # or t_array[-t % 60]
    t_array[t % 60] += 1
  return count
```

### O(n) time | O(1) space (from O(60))
