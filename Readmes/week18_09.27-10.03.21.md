# Algorithm practice

* Java documentations and extra notes are in each file.
* Solutions displayed here are preferably the most optimal
    * Alternative (less optimal) solutions might also be available within each 
    file

# Week 18: 09/27 - 10/03/2021

# Category for this week:

---

## [Leetcode #146 - LRU Cache](https://leetcode.com/problems/lru-cache/)

#### Level: Medium ðŸ“˜

```python
class LRUCache:

  # can capacity be negative? If so, need validation? return 0?

  def __init__(self, capacity):
    """
    :type capacity: int
    """
    self.capacity = capacity
    self.cache = OrderedDict()
      

  def get(self, key):
    """
    :type key: int
    :rtype: int
    """
    if key in self.cache:
        self.cache.move_to_end(key)
        return self.cache[key]
    return -1
      

  def put(self, key, value):
    """
    :type key: int
    :type value: int
    :rtype: None
    """
    if key in self.cache:
      self.cache.update({key: value})
      self.cache.move_to_end(key)
      return
    
    if self.capacity == len(self.cache):
      self.cache.popitem(last=False)
    
    # this works for the above if statement and also when capacity isn't met
    self.cache.update({key: value})
```
> This implementation works for Python3 and above, Python2 doesn't support function `move_to_end()` and `popitem()` of dict.

### O(1) time | O(1) space - as expected from the question
